---
title: dataGen2
output:
  pdf_document: default
  html_document: default
---

## Sanity check

```{r initt, warning=FALSE, cache=TRUE, include=FALSE}
library(PsyFuns)
library(dplyr)
library(ggplot2)
library(tidyr)
```




```{r parameters, cache=TRUE}
#Stimulus distributions (sampling scheme)
setsOfPredictors <- list(
  data.frame(predictor=c(7.1,8,8.8,9.1,9.9,10.9), observations=c(rep(160,6)), distr=c(rep(1,6))),
  data.frame(predictor=c(4.75,7.1,8,9.9,10.9,13), observations=c(rep(160,6)), distr=c(rep(2,6))), 
  data.frame(predictor=c(7,8.5,10.8,11.5,13,16), observations=c(rep(160,6)), distr=c(rep(3,6))),
  data.frame(predictor=c(4.75,6,7,8,9,10), observations=c(rep(160,6)), distr=c(rep(4,6))),
  data.frame(predictor=c(4.5,6,7,10.75,12.5,17), observations=c(rep(160,6)), distr=c(rep(5,6))),
  data.frame(predictor=c(7,8,9,10,11,17), observations=c(rep(160,6)), distr=c(rep(6,6))),
  data.frame(predictor=c(7.5,8,9.2,12,13,16), observations=c(rep(160,6)), distr=c(rep(7,6)))
)

#Data generating functions + parameters
functions <- list(
   PF("gumbel_r", "linear",   0,0, c(1, -9.2 - log(log(2)))),
  PF("gumbel_l", "linear",   0,0, c(1, -9.2 + log(log(2)))),
  PF("logistic", "linear",  0,0,   c(1, -9.2)),
  PF("gauss", "linear",       0,0, c(1, -9.2)),
  PF("cauchy", "linear",      0,0, c(1, -9.2)),
  PF("htan", "linear",        0,0, c(1, -9.2)),
  
  
  PF("gumbel_r", "ab",    0,0, c(9.2 + log(log(2)),1)),
  PF("gumbel_l", "ab",    0,0, c(9.2 - log(log(2)),1)),
  PF("logistic", "ab",    0,0, c(9.2, 1)),
  PF("gauss",    "ab",    0,0,    c(9.2, 1)),
  PF("cauchy",   "ab",    0,0,   c(9.2, 1)),
  PF("htan",     "ab",    0,0,     c(9.2, 1)),
  
  
  PF("gumbel_r", "al",    0,0, c(9.2 + log(log(2)),1)),
  PF("gumbel_l", "al",    0,0, c(9.2 - log(log(2)),1)),
  PF("logistic", "al",    0,0, c(9.2, 1)),
  PF("gauss",    "al",    0,0,    c(9.2, 1)),
  PF("cauchy",   "al",    0,0,   c(9.2, 1)),
  PF("htan",     "al",    0,0,     c(9.2, 1)),
  
   PF("gumbel_r", "linear",    0,0, c(0.5, -4.6 - log(log(2)))),
  PF("gumbel_l", "linear",    0,0, c(0.5, -4.6 + log(log(2)))),
  PF("logistic", "linear",    0,0, c(0.5, -4.6)),
  PF("gauss", "linear",   0,0,     c(0.5, -4.6)),
  PF("cauchy", "linear",  0,0,     c(0.5, -4.6)),
  PF("htan", "linear",    0,0,     c(0.5, -4.6)),
  
PF("gumbel_r", "al",    0,0, c(9.2 + log(log(2))*2,0.5)),
  PF("gumbel_l", "al",    0,0, c(9.2 - log(log(2))*2,0.5)),
  PF("logistic", "al",    0,0, c(9.2, 0.5)),
  PF("gauss",    "al",    0,0,    c(9.2, 0.5)),
  PF("cauchy",   "al",    0,0,   c(9.2, 0.5)),
  PF("htan",     "al",    0,0,     c(9.2, 0.5)),
  
  PF("gumbel_r", "ab",    0,0, c(9.2 + log(log(2))*2,2)),
  PF("gumbel_l", "ab",    0,0, c(9.2 - log(log(2))*2,2)),
  PF("logistic", "ab",    0,0, c(9.2, 2)),
  PF("gauss",    "ab",    0,0,    c(9.2, 2)),
  PF("cauchy",   "ab",    0,0,   c(9.2, 2)),
  PF("htan",     "ab",    0,0,     c(9.2, 2))


)

#Fitting functions
fitters <- list(
  c("gumbel_l", "linear"),
  c("logistic", "linear"),
  c("cauchy", "linear"),
  c("gauss", "linear")
)

#noise type and parameters
noise <- list(
    list("logistic", 0, 0.1),
    list("logistic", 0, 0.05),
    list("logistic", 0, 0.01)
)

#nuber of generations per one generating function + predicting stimulus + noise properties
NOG <- 100

```

\newpage

## Generating functions

Visualization generating functions. Predictor distributions are also visualized.

```{r data, warning=FALSE, cache=TRUE, echo=FALSE, message=FALSE}
set.seed(18032019)

underlyingFunction <- function(pf){
  data <- data.frame(predictor=seq(3,21, length.out = 100))
  data$sigmoid_gen <- rep(pf$sigmoid, nrow(data))
  data$core_gen <- rep(pf$core, nrow(data))
  data$gamma_gen <- rep(pf$gamma, nrow(data))
  data$lambda_gen <- rep(pf$lambda, nrow(data))
  data$params.1_gen <- rep(pf$params[1], nrow(data))
  data$params.2_gen <- rep(pf$params[2], nrow(data))
  data$PC <- predict(pf, data$predictor)

  return(data)
}

underlyingFunctions <- lapply(functions, underlyingFunction)
underlyingFunctions <- do.call(rbind, underlyingFunctions)

id_pred <- seq(1,length(setsOfPredictors))

my_f <- function(pf){
  my_finner <- function(gen, id){
    pfm <- PFm(pf, gen$predictor, gen$observations)
    pfm$id_pred <- id
    pfm$id_predDistr <- gen$distr
    return(pfm)
  }
  generator <- mapply(my_finner, setsOfPredictors, id_pred, SIMPLIFY = FALSE)
  return(generator)
}

generators <- unlist(lapply(functions, my_f), recursive = FALSE)

ids <- 1:length(generators)
ids <- as.list(ids)

addID <- function(pfm, id){
  pfm$id <- id
  return(pfm)
}

generators <- mapply(addID, generators, ids, SIMPLIFY = FALSE)

inwrite <- function(pfm){
  pfm$data$sigmoid_gen <- rep(pfm$sigmoid, nrow(pfm$data))
  pfm$data$core_gen <- rep(pfm$core, nrow(pfm$data))
  pfm$data$gamma_gen <- rep(pfm$gamma, nrow(pfm$data))
  pfm$data$lambda_gen <- rep(pfm$lambda, nrow(pfm$data))
  pfm$data$params.1_gen <- rep(pfm$params[1], nrow(pfm$data))
  pfm$data$params.2_gen <- rep(pfm$params[2], nrow(pfm$data))
  pfm$data$id_gen <- pfm$id
  pfm$data$id_predDistr <- pfm$id_predDistr
  pfm$data$id_pred <- pfm$id_pred
  pfm$data$perf_th <- pfm$perf_th
  pfm$data$imp_th <- pfm$imp_th
  pfm$data$log_lik_orig <- PsyMetFuns:::log_likelihood(pfm)
  return(pfm)
  
}

generators <- lapply(generators,inwrite)

extract_data <- function(pfm){
  return(pfm$data)
}

generators_data.frame <- lapply(generators, extract_data)
generators_data.frame <- do.call(rbind, generators_data.frame)

predictors_data.frame <- generators_data.frame[c("predictor", "id_pred", "id_gen", "observations")]
predictors_data.frame <- predictors_data.frame 

```

```{r data_plot, warning=FALSE, cache=TRUE, echo=FALSE, message=FALSE}
set.seed(18032019)

plot <- ggplot()
plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC, group=underlyingFunctions$params.2_gen), linetype="dashed", alpha=0.5)
plot <- plot + geom_point(data=generators_data.frame,mapping=aes(x=predictor, y=0.45 * id_predDistr / max(id_predDistr)), fill="gray", shape=as.factor(generators_data.frame$id_predDistr), alpha=0.8)
plot <- plot + geom_line(data=generators_data.frame,mapping=aes(x=predictor, y=0.45 * id_predDistr / max(id_predDistr), group=id_predDistr), alpha=0.8)
plot <- plot + facet_wrap("sigmoid_gen")
plot <- plot + ylim(0,1)
plot <- plot + scale_x_continuous(trans="log2")
plot

```

\newpage

## Generating noise

Visualizing the generation of noise in generated data. Noise is created by normal distribution with mean = 0 and various standard deviation. Color marks the magnitude of standard deviation.

```{r generating+noise, cache=TRUE, warning=FALSE, echo=FALSE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}
set.seed(18032019)

gensnoise <- expand.grid(noise,generators)

adding_noise <- function(pfm, noise){
  pfm$noise <- TRUE
  pfm$noiseParams <- noise
  return(pfm)
}

generated <- mapply(adding_noise, gensnoise[,2], gensnoise[,1], SIMPLIFY = FALSE)

generating_instances <- function(pfm){
  list <- rep(list(pfm), NOG)
  
  gen <- function(pfm){
    pfm$data$PC_gen <- PsyMetFuns::noisedPredict(pfm, pfm$data$predictor,   unlist(pfm$noiseParams[1]), unlist(pfm$noiseParams[2]), unlist(pfm$noiseParams[3])) 
    pfm$data$PC_gen <- round(pfm$data$PC_gen * pfm$data$observations) / pfm$data$observations #rounding
    pfm$formula <- as.formula(c(PC_gen, observations) ~ predictor)
    pfm$data$noiseType <- unlist(pfm$noiseParams[1])
    pfm$data$noise_mean <- as.factor(unlist(pfm$noiseParams[2]))
    pfm$data$noise_sd <- as.factor(unlist(pfm$noiseParams[3]))
    pfm$data$log_likelihood_gen_noised <- PsyMetFuns:::log_likelihood(pfm)
    pfm$data$log_likelihood_ratio_gen_noised <- PsyMetFuns:::log_likRatio(pfm)
    pfm$data$pearson_x_gen_noised <- PsyMetFuns:::pearsonx(pfm)

    return(pfm)
  }
  
  list <- lapply(list, gen)
  
  return(list)
}

  generated <- unlist(lapply(generated, generating_instances), recursive = FALSE)

  ids <- 1:length(generated)
  ids <- as.list(ids) 
  
  addSimultationID <- function(pfm, id){
    pfm$id_sim <- id
    pfm$data$id_sim <- pfm$id_sim
    
    return(pfm)
  }
  
generated <- mapply(addSimultationID, generated, ids, SIMPLIFY = FALSE)

generated_data.frame <- lapply(generated, extract_data)
generated_data.frame <- bind_rows(generated_data.frame)

```

```{r generating+noise_plot, cache=TRUE, warning=FALSE, echo=FALSE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}
set.seed(18032019)

plot <- ggplot()
plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC), linetype="dashed", alpha=0.5)
plot <- plot + geom_point(data=generated_data.frame,mapping=aes(x=predictor, y=PC_gen, colour=as.factor(noise_sd)), shape=as.factor(generated_data.frame$id_pred), alpha=0.8)
plot <- plot + facet_wrap("sigmoid_gen","core_gen")
plot <- plot + ylim(0,1)
plot
```

## Visualizing simulations

Visualization of all simulation. Divided into columns by generating functions and and in rows by types of predictor distribution and magnitude of noise standard deviation.

```{r generating+noise_continoues,warning=FALSE, echo=FALSE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

library(ggplot2)
plot <- ggplot()
plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC), linetype="dashed", alpha=0.5)
plot <- plot + geom_point(data=generated_data.frame,mapping=aes(x=predictor, y=PC_gen, colour=noise_sd), shape=as.factor(generated_data.frame$id_pred), alpha=0.8)
plot <- plot + geom_line(data=generated_data.frame,mapping=aes(x=predictor, y=PC_gen, color=noise_sd, group=as.factor(id_sim)),  alpha=0.5)
plot <- plot + facet_grid(id_pred + noise_sd ~ sigmoid_gen + core_gen)
plot <- plot + ylim(0,1)
plot
```

```{r fit, echo=FALSE, cache=TRUE, export=TRUE, warning=FALSE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo") }
set.seed(2900)

fit <- function(func){
  return(fitPFm(c(PC_gen, observations)~predictor, data = generated_data.frame ,sigmoid = func[[1]], core = func[[2]], control=list(maxit=10000), type="PC", split_by = "id_sim", gamma = 0.5, algorithm = def_fixed_gamma))
}

fitted <- unlist(lapply(fitters, fit), recursive = FALSE)

ids <- 1:length(fitted)
ids <- as.list(ids) 
  
addFitID <- function(pfm, id){
    pfm$id_fit <- id
    pfm$data$id_fit <- pfm$id_fit
    pfm$data$sigmoid_fit <- pfm$sigmoid
    pfm$data$core_fit <- pfm$core
    pfm$data$gamma_fit <- pfm$gamma
    pfm$data$lambda_fit <- pfm$lambda
    pfm$data$params.1_fit <- pfm$params[1]
    pfm$data$params.2_fit <- pfm$params[2]
    pfm$data$lh_value <- pfm$value
    pfm$data$PC_fit <- predict(pfm, pfm$data$predictor)
    pfm$data$perf_th_fit <- pfm$perf_th
    pfm$data$imp_th_fit <- pfm$imp_th
    pfm$data$log_likelihood_fit <- pfm$log_likelihood
    pfm$data$log_likelihood_ratio_fit <- pfm$log_likelihood_ratio
    pfm$data$pearson_x_fit <- pfm$pearson_x

    return(pfm)
}

fitted <- mapply(addFitID, fitted, ids, SIMPLIFY = FALSE)

fitted_data.frame <- lapply(fitted, extract_data)
fitted_data.frame <-bind_rows(fitted_data.frame)


underlyingFunction_fit <- function(pf){
  data <- data.frame(predictor=seq(-1,21, length.out = 100))
  data$PC <- predict(pf, data$predictor)
  
  data <- merge(data,pf$data[1,][!(names(pf$data[1,]) %in% c("predictor", "PC", "PC_gen", "PC_fit"))])
  
  return(data)
}

underlyingFunctions_fitted <- lapply(fitted, underlyingFunction_fit)
underlyingFunctions_fitted <- bind_rows(underlyingFunctions_fitted)

pred_data.frame <-  fitted_data.frame %>% select(sigmoid_gen, core_gen, id_pred, predictor, PC, sigmoid_fit, core_fit) %>% unique()

```

\newpage

##Gauss fitting

Visualization of simulation fits by gauss function. Colums are divided by generating function and rows by type of distribution. Color marks the standard distribution magnitude

```{r fit_gauss, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

underlyingFunctions_fitted_chopped <- underlyingFunctions_fitted %>% filter(sigmoid_fit=="gauss", core_fit=="ab")
#pred_data.frame_chopped <- pred_data.fram %>% filter(sigmoid_fit=="gauss", core_fit=="ab")

plot <- ggplot()
#plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC), linetype="dashed", alpha=0.5)
plot <- plot + geom_line(data=(underlyingFunctions_fitted_chopped), mapping = aes(x=predictor, y=PC, group = as.factor(id_fit) , col=as.factor(noise_sd)), alpha=0.5)
#plot <- plot + geom_point(data=pred_data.frame_chopped,mapping=aes(x=predictor, y=PC, shape=as.factor(id_pred)), col="blue", alpha=0.8)
#plot <- plot + geom_point(data=generated_data.frame,mapping=aes(x=predictor, y=generatedPC, colour=as.factor(noise_sd)), shape=as.factor(generated_data.frame$id_pred), alpha=0.001)
plot <- plot + facet_grid(id_predDistr ~ sigmoid_gen + core_gen )
#plot <- plot + facet_wrap(c("sigmoid_gen","core_gen", "id_pred"), ncol = 2)
plot <- plot + ylim(0,1)
plot
```

\newpage

##Gumbel_l fitting

Visualization of simulation fits by left gumbel function. Colums are divided by generating function and rows by type of distribution. Color marks the standard distribution magnitude.

```{r fit_gumbel_l, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

underlyingFunctions_fitted_chopped <- underlyingFunctions_fitted %>% filter(sigmoid_fit=="gumbel_l", core_fit=="ab")
#pred_data.frame_chopped <- pred_data.fram %>% filter(sigmoid_fit=="gauss", core_fit=="ab")

plot <- ggplot()
#plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC), linetype="dashed", alpha=0.5)
plot <- plot + geom_line(data=(underlyingFunctions_fitted_chopped), mapping = aes(x=predictor, y=PC, group = as.factor(id_fit), col=as.factor(noise_sd)), alpha=0.5)
#plot <- plot + geom_point(data=pred_data.frame_chopped,mapping=aes(x=predictor, y=PC, shape=as.factor(id_pred)), col="blue", alpha=0.8)
#plot <- plot + geom_point(data=generated_data.frame,mapping=aes(x=predictor, y=generatedPC, colour=as.factor(noise_sd)), shape=as.factor(generated_data.frame$id_pred), alpha=0.001)
plot <- plot + facet_grid( id_predDistr ~ sigmoid_gen + core_gen )
#plot <- plot + facet_wrap(c("sigmoid_gen","core_gen", "id_pred"), ncol = 2)
plot <- plot + ylim(0,1)
plot
```

\newpage

##Cauchy fitting

Visualization of simulation fits by cauchy function. Colums are divided by generating function and rows by type of distribution. Color marks the standard distribution magnitude

```{r fit_cauchy, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}
underlyingFunctions_fitted_chopped <- underlyingFunctions_fitted %>% filter(sigmoid_fit=="cauchy", core_fit=="ab")
#pred_data.frame_chopped <- pred_data.fram %>% filter(sigmoid_fit=="gauss", core_fit=="ab")

plot <- ggplot()
#plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC), linetype="dashed", alpha=0.5)
plot <- plot + geom_line(data=(underlyingFunctions_fitted_chopped), mapping = aes(x=predictor, y=PC, group = as.factor(id_fit), col=as.factor(noise_sd)), alpha=0.5)
#plot <- plot + geom_point(data=pred_data.frame_chopped,mapping=aes(x=predictor, y=PC, shape=as.factor(id_pred)), col="blue", alpha=0.8)
#plot <- plot + geom_point(data=generated_data.frame,mapping=aes(x=predictor, y=generatedPC, colour=as.factor(noise_sd)), shape=as.factor(generated_data.frame$id_pred), alpha=0.001)
plot <- plot + facet_grid( id_predDistr~ sigmoid_gen + core_gen )
#plot <- plot + facet_wrap(c("sigmoid_gen","core_gen", "id_pred"), ncol = 2)
plot <- plot + ylim(0,1)
plot
```


\newpage
##Logistic fitting

Visualization of simulation fits by Logistic function. Colums are divided by generating function and rows by type of distribution. Color marks the standard distribution magnitude

```{r fit_logistic, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

underlyingFunctions_fitted_chopped <- underlyingFunctions_fitted %>% filter(sigmoid_fit=="logistic", core_fit=="ab")
#pred_data.frame_chopped <- pred_data.fram %>% filter(sigmoid_fit=="gauss", core_fit=="ab")

plot <- ggplot()
#plot <- plot + geom_line(data=underlyingFunctions, mapping = aes(x=predictor, y=PC), linetype="dashed", alpha=0.5)
plot <- plot + geom_line(data=(underlyingFunctions_fitted_chopped), mapping = aes(x=predictor, y=PC, group = as.factor(id_fit), , col=as.factor(noise_sd)), alpha=0.5)
#plot <- plot + geom_point(data=pred_data.frame_chopped,mapping=aes(x=predictor, y=PC, shape=as.factor(id_pred)), col="blue", alpha=0.8)
#plot <- plot + geom_point(data=generated_data.frame,mapping=aes(x=predictor, y=generatedPC, colour=as.factor(noise_sd)), shape=as.factor(generated_data.frame$id_pred), alpha=0.001)
plot <- plot + facet_grid(id_predDistr ~ sigmoid_gen + core_gen )
#plot <- plot + facet_wrap(c("sigmoid_gen","core_gen", "id_pred"), ncol = 2)
plot <- plot + ylim(0,1)
plot
```

\newpage

##Threshold distances - Improvement threshold 

Visualizing distance betweeen original improvement treshold and fitted improvement threshold. Distances are sorted to column sections by fitting funtions and to columns by generating functions.

```{r threshold_imp, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

fitted_data.frame_chopped <- fitted_data.frame %>% mutate(imp_th_dist=abs(imp_th_fit - imp_th)) #%>% filter(imp_th_dist < 1000)

plot <- ggplot()
plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=sigmoid_gen,y=imp_th_dist, col=as.factor(noise_sd)))
plot <- plot + facet_grid( . ~ sigmoid_fit + core_fit )
plot <- plot + theme(axis.text.x = element_text(angle=90))
plot
```

\newpage

###Improvement threshold logarithmic scale

Visualizing distance between original improvement threshold and fitted improvement threshold in logarithmic scale. Distances are sorted to column sections by fitting funtions and to columns by generating functions.

```{r threshold_imp_log, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

fitted_data.frame_chopped <- fitted_data.frame %>% mutate(imp_th_dist_log=log(abs(imp_th_fit - imp_th))) #%>% filter(imp_th_dist < 1000)

plot <- ggplot()
#plot <- plot + geom_boxplot(data=fitted_data.frame_chopped, mapping=aes(x=sigmoid_fit, y=imp_th_dist_log))
plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=sigmoid_gen,y=imp_th_dist_log, col=as.factor(noise_sd)))
plot <- plot + facet_grid( . ~ sigmoid_fit + core_fit )
plot <- plot + theme(axis.text.x = element_text(angle=90))
plot
```
\newpage

###Performance threshold 

Visualizing distance betweeen original performance treshold and fitted performance threshold. Distances are sorted to column sections by fitting funtions and to columns by generating functions.

```{r threshold_perf, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}


fitted_data.frame_chopped <- fitted_data.frame %>% mutate(perf_th_dist=abs(perf_th_fit - perf_th)) #%>% filter(perf_th_dist < 50)

plot <- ggplot()
plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=sigmoid_gen,y=perf_th_dist, col=as.factor(noise_sd)))
plot <- plot + facet_grid( . ~ sigmoid_fit + core_fit )
plot <- plot + theme(axis.text.x = element_text(angle=90))
plot
```

\newpage

###Performance threshold logarithmic scale

Visualizing distance between original performance threshold and fitted performance threshold in logarithmic scale. Distances are sorted to column sections by fitting funtions and to columns by generating functions.

```{r threshold_perf_log, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

fitted_data.frame_chopped <- fitted_data.frame %>% mutate(perf_th_dist_log=log(abs(perf_th_fit - perf_th))) %>% mutate(imp_th_dist_log=log(abs(imp_th_fit - imp_th)))#%>% filter(imp_th_dist < 1000)

plot <- ggplot()
plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=sigmoid_gen,y=perf_th_dist_log, col=as.factor(noise_sd)))

plot <- plot + facet_grid( . ~ sigmoid_fit + core_fit )
plot <- plot + theme(axis.text.x = element_text(angle=90))
plot
```

\newpage


###Performance threshold - threshold relation
Visualizing the relation between performance and improvement threshold distances in logarithmic scale. Improvement threshold is denoted on axis x and performance threshold is denoted on axis y. Instances are sorted to columns by fitting funtions and to rows by generating functions.

```{r thresholds_intermidiate_dist, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

fitted_data.frame_chopped <- fitted_data.frame %>% mutate(perf_th_dist_log=log(abs(perf_th_fit - perf_th))) %>% mutate(imp_th_dist_log=log(abs(imp_th_fit - imp_th)))#%>% filter(imp_th_dist < 1000)

plot <- ggplot()
plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=imp_th_dist_log,y=perf_th_dist_log, col=as.factor(noise_sd)))

plot <- plot + facet_grid( sigmoid_gen + core_gen ~ sigmoid_fit + core_fit )
plot

```
\newpage


##Improvement threshold distribution histograms

Visualizing distance betweeen original improvement treshold and fitted improvement threshold in logarithmic scale by histograms. Distances are sorted to column sections by fitting funtions and to rows by generating functions, withing sections are separated by variance.

```{r threshold_imp_log_by_variance, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

fitted_data.frame_chopped <- fitted_data.frame %>% mutate(imp_th_dist_log=log(abs(imp_th_fit - imp_th))) #%>% filter(imp_th_dist < 1000)

plot <- ggplot()
#plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=as.factor(noise_sd),y=imp_th_dist_log, col=as.factor(noise_sd)))
plot <- plot + geom_boxplot(data=fitted_data.frame_chopped,mapping=aes(x=as.factor(noise_sd),y=imp_th_dist_log, col=as.factor(noise_sd)))
plot <- plot + facet_grid( sigmoid_gen + core_gen ~ sigmoid_fit + core_fit )
plot
```

\newpage

##Performace hreshold distribution histograms

Visualizing distance betweeen original improvement treshold and fitted improvement threshold in logarithmic scale by histograms. Distances are sorted to column sections by fitting funtions and to rows by generating functions, withing sections are separated by variance.

```{r threshold_perf_log_by_variance, echo=FALSE, cache=TRUE, export=TRUE, message=FALSE, fig.path = "./", fig.width = 7, fig.height = 8, out.width = "7in", out.height = "8in", dpi = 300, dev = "png", dev.args = list(type = "cairo")}

fitted_data.frame_chopped <- fitted_data.frame %>% mutate(perf_th_dist_log=log(abs(perf_th_fit - perf_th))) #%>% filter(imp_th_dist < 1000)

plot <- ggplot()
#plot <- plot + geom_point(data=fitted_data.frame_chopped,mapping=aes(x=as.factor(noise_sd),y=imp_th_dist_log, col=as.factor(noise_sd)))
plot <- plot + geom_boxplot(data=fitted_data.frame_chopped,mapping=aes(x=as.factor(noise_sd),y=perf_th_dist_log, col=as.factor(noise_sd)))
plot <- plot + facet_grid( sigmoid_gen + core_gen ~ sigmoid_fit + core_fit )
plot
```

